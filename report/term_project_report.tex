\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts,amsthm}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{simplebnf}
\usepackage{bussproofs}
\usepackage{stmaryrd}
\usepackage{float}
\usepackage[colorlinks]{hyperref}
\EnableBpAbbreviations
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\newcommand\lam[2]{\lambda #1.#2}
\newcommand\unp[3]{\textbf{let }[#1]=#2\textbf{ in }#3}
\newcommand\une[2]{\textbf{let }\unt=#1\textbf{ in }#2}
\newcommand\gradedt[2]{\square_#1 #2}
\newcommand\public{\texttt{Pub}}
\newcommand\secret{\texttt{Sec}}
\newcommand\irrele{\texttt{Irrelevant}}
\newcommand\secure{\mathbb{S}}
\newcommand\true{\texttt{true}}
\newcommand\false{\texttt{false}}
\newcommand\bool{\texttt{Bool}}
\newcommand\nat{\texttt{Nat}}
\newcommand\suc[1]{\texttt{succ}\; #1}
\newcommand\prd[1]{\texttt{pred}\; #1}
\newcommand\iszero[1]{\texttt{iszero}\; #1}
\newcommand\unt{()}
\newcommand\untt{\texttt{Unit}}
\newcommand\cond[3]{\textbf{if }#1\textbf{ then }#2\textbf{ else }#3}
\newcommand\srzero{\textbf{0}}
\newcommand\srone{\textbf{1}}
\newcommand\reduce{\rightsquigarrow}
\newcommand\calv{\mathcal{V}}
\newcommand\cale{\mathcal{E}}

\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\begin{document}

\title{\textsc{FlowSTLC}: An Information Flow Control Type System Based On Graded Modality
}

\author{\IEEEauthorblockN{1\textsuperscript{st} Zhige Chen}
\IEEEauthorblockA{\textit{Dept. of Computer Science}\\\textit{and Engineering} \\
\textit{Southern University of}\\\textit{Science and Technology}\\
Shenzhen, China \\
12413315@mail.sustech.edu.cn}
\and
\IEEEauthorblockN{2\textsuperscript{nd} Junqi Huang}
\IEEEauthorblockA{\textit{Dept. of Computer Science}\\\textit{and Engineering} \\
\textit{Southern University of}\\\textit{Science and Technology}\\
Shenzhen, China \\
12212226@mail.sustech.edu.cn}
\and
\IEEEauthorblockN{3\textsuperscript{rd} Zhiyuan Cao}
\IEEEauthorblockA{\textit{Dept. of Computer Science}\\\textit{and Engineering} \\
\textit{Southern University of}\\\textit{Science and Technology}\\
Shenzhen, China \\
12311109@mail.sustech.edu.cn}
}

\maketitle

\begin{abstract}
In this project, we introduce the design and implementation of a simple functional programming language with a type system that enforces secure information flow. Building on the simply-typed lambda calculus (STLC), we extend the type system with a graded modality with a security semiring. Inspired by \textit{Graded Modal Dependent Type Theory} \cite{moon2021graded}, our system statically prevents unauthorized flows of sensitive data into public outputs, ensuring the noninterference property \cite{smith2007principles}.
\end{abstract}

\begin{IEEEkeywords}
Computer security, information flow, noninterference, security-type systems
\end{IEEEkeywords}

\section{Introduction}

Modern software often handles sensitive data that must remain confidential. The \emph{informational flow control} (or IFC) aims to ensure that high-security inputs of the program do not improperly influence low-security outputs. For example, private user information like passwords should never be leaked to public logs. Formally, the security policy of \emph{noninterference} requires that variations in high-security inputs have no observable effect on low-security outputs. Intuitively, this means that changing a secret value should never cause any change in what an outside observer at low level sees. Violating the IFC principle can lead to information leak, so enforcing noninterference is critical for system security.

\emph{Type systems} \cite{sabelfeld2003language} \cite{abadi1999core} have been proved effective at enforcing noninterference: they associate each value with a \emph{security label} and constrain operations so that a well-typed program is guaranteed not to leak high-security information. For example, consider the following function:

\begin{equation}
	\text{foo}=\lam{x:\nat}{\lam{y:\nat}{x+y}}
\end{equation}

Then such coeffect systems might allow the function to be typed as
\begin{equation}
	\text{foo}:\nat^\secret\to\nat^\public\to\nat^\secret
\end{equation}
where the first parameter is marked as a high-security input, and the second parameter is marked as a low-security input. If a low-security result depends on a high-security input, the type system would reject the program. Thus, those security type systems can automatically verify that programs adhere to confidentiality policies.

However, existing IFC type systems can be rather inflexible or coarse-grained. Many system treat security labels in a rigid, lattice-based way \cite{denning1976lattice}, and often difficult to coexist with other sophisticated type system constructs. To address these issues, we propose the \textsc{FlowSTLC}, a more flexible and extensible type system that track informational flows with \emph{graded modalities}. More specifically, we will design a simply typed lambda-calculus with integrated \emph{graded necessity} for the semiring $\{\public\sqsubseteq\secret\}$, where $\public$ represents low-security information, and $\secret$ represents high-security information. This system will allow us precisely control how the values interact as a type of \emph{coeffects} \cite{petricek2013coeffects} \cite{petricek2014coeffects}, while remain easy to extend with other program reasoning constructs like the \emph{usage analysis} \cite{orchard2019quantitative}.

\section{\textsc{FlowSTLC}: The Core Calculus}
\subsection{Syntax}

The \textsc{FlowSTLC} is a graded extension to the simply typed lambda-calculus resembling the Fuzz type system of Reed et al. \cite{reeddistance}. It is also similar to coeffect calculi of Brunel et al. \cite{brunel2014core} and Gaboardi et al. \cite{gaboardi2016combining}.

The syntax of \textsc{FlowSTLC} is a straightforward extension of STLC with two additional constructs for introducing and eliminating the graded necessity type $\gradedt{\ell}{T}$. We also add built-in boolean, natural numbers, and unit type to it:

\begin{figure}[H]
	\centering
	$$
	\begin{aligned}
		\textsf{Term}\;t\;&::=&\;x\;|\;t\; t\;|\;\lambda x.t\;|\;[t]\;|\;\textbf{let }[x]=t\textbf{ in }t\\
		&&\true\;|\;\false\;|\;\cond{t}{t}{t}\;|\; n\\
		&&\iszero{t}\;|\;\unt\;|\;\une{t}{t}\\
		\textsf{Type}\;T\;&::=&\;T\to^\ell T\;|\;\square_r T\;|\;\untt\;|\;\bool\;|\;\nat\\
	\end{aligned}
	$$
	\caption{Syntax of \textsc{FlowSTLC}}
\end{figure}

The syntax $[t]$ promotes a term to a graded modality, and $\unp{x}{t_1}{t_2}$ eliminate the modalities by checking whether $t_2$ uses $t_1$ w.r.t. its grade, and, if satisfied, "unbox" the modality and substitute it into $t_2$. The function type $T\to^\ell T$ records how will the function use its argument by a grade $\ell$. The graded modality $\gradedt{\ell}{T}$ is a type constructor where $\ell$ comes from the \emph{security level algebra}, i.e., a semiring $\secure=\public\sqsubseteq\secret$. The built-in booleans, natural numbers, and unit types are easy and well-studied extensions, and we will omit the explanation of these constructs here.

Typing judgements are of the regular form $\Gamma\vdash t:T$ with the typing contexts of the form:
$$
\textsf{Context}\;\Gamma\;::=\;\emptyset\;|\;\Gamma,x:[T]_\ell
$$

Contexts are either empty $\emptyset$, or can be extended with  a \emph{graded assumption} $x:[T]_\ell$. For graded assumptions, their grades $\ell$ capture their substructural behavior by describing how can they be used in a term, in this case, the grade capture the security level of information. We will use $dom(\Gamma)$ to denote the variables assigned by context $\Gamma$.

\subsection{Typing}

\textsc{FlowSTLC} has all three standard typing rules of STLC:
\begin{figure}[H]
	\centering
	\begin{prooftree}
		\AXC{}
		\RightLabel{\textsc{T-Var}}
		\UIC{$\srzero\cdot\Gamma,x:[T]_\srone\vdash x:T$}
	\end{prooftree}
	
	\begin{prooftree}
		\AXC{$\Gamma,x:[T_1]_\ell\vdash t:T_2$}
		\RightLabel{\textsc{T-Abs}}
		\UIC{$\Gamma\vdash\lam{x:T_1}{t}:T_1\to^\ell T_2$}
	\end{prooftree}
	
	\begin{prooftree}
		\AXC{$\Gamma_1\vdash t_1:T_{11}\to^\ell T_{12}$}
		\AXC{$\Gamma_2\vdash t_2:T_{11}$}
		\RightLabel{\textsc{T-App}}
		\BIC{$\Gamma_1+\ell\cdot\Gamma_2\vdash t_1\; t_2:T_{12}$}
	\end{prooftree}
	\caption{STLC rules in \textsc{FlowSTLC}}
\end{figure}

The exchange rule and weakening rule that allow permutation and expansion of contexts is implicit here, instead we enables the permutation by a permutation lemma (see \hyperref[lem-perm]{Permutation lemma}). The differences with the standard rules are that these rules integrate grades into the premises and conclusions. For example, the \textsc{T-Var} rule enforces that we only use $x$ by requiring all other assumptions have a $\secret$ grade. And the abstraction rule \textsc{T-Abs} records the usage of variable $x$ in function body by marking the function's type with the same grade of the assumption that assigns $x$. For the application rule \textsc{T-App}, the concatenation combines all graded assumptions by the semiring addition $+$ (for more information see the \hyperref[def-concat]{Appendix A.3}).

The next three rules build the structure of the security label semiring:
\begin{figure}[H]
	\centering
	\begin{prooftree}
		\AXC{$\Gamma\vdash t:T$}
		\RightLabel{\textsc{T-Pro}}
		\UIC{$\ell\cdot\Gamma\vdash[t]:\gradedt{\ell}{T}$}
	\end{prooftree}
	
	\begin{prooftree}
		\AXC{$\Gamma_1\vdash t_1:\gradedt{\ell}{T_1}$}
		\AXC{$\Gamma_2,x:[T_1]_\ell\vdash t_2:T_2$}
		\RightLabel{\textsc{T-Let}}
		\BIC{$\Gamma_1+\Gamma_2\vdash\unp{x}{t_1}{t_2}:T_2$}
	\end{prooftree}
	
	\begin{prooftree}
		\AXC{$\Gamma,x:[T_2]_{\ell_1}\vdash t:T_1$}
		\AXC{$\ell_2\sqsubseteq\ell_1$}
		\RightLabel{\textsc{T-Approx}}
		\BIC{$\Gamma,x:[T_2]_{\ell_2}\vdash t:T_1$}
	\end{prooftree}
	\caption{Grade Rules in \textsc{FlowSTLC}}
\end{figure}

The \emph{Promotion} rule \textsc{T-Pro} "promotes" a regular term $t$ to a graded modality by propagating its resource requirement to the context by a \emph{scalar multiplication} (for complete definition of scalar multiplication, see the \hyperref[def-mul]{Appendix A.3}). The \textsc{T-Let} rule provides a way to eliminate graded modality via substitution, where graded value is "unboxed" and substituted into a graded assumption with matching grades. The context concatenation is also used in the conclusion. Finally, the \emph{approximation} rule \textsc{T-Approx} allows us to "loosen" the requirement if $\ell_2\sqsubseteq\ell_1$.

The remaining rules specify the types of booleans, natural numbers, unit values, and conditionals, etc.

\begin{figure}[H]
	\centering
	\begin{prooftree}
		\AXC{}
		\RightLabel{\textsc{T-True}}
		\UIC{$\srzero\cdot\Gamma\vdash\true:\bool$}
	\end{prooftree}
	
	\begin{prooftree}
		\AXC{}
		\RightLabel{\textsc{T-False}}
		\UIC{$\srzero\cdot\Gamma\vdash\false:\bool$}
	\end{prooftree}
	
	\begin{prooftree}
		\def\defaultHypSeparation{\hskip .03in}
		\AXC{$\Gamma_1\vdash t_1:\bool$}
		\AXC{$\Gamma_2\vdash t_2:T$}
		\AXC{$\Gamma_2\vdash t_3:T$}
		\AXC{$\ell\sqsubseteq\srone$}
		\RightLabel{\textsc{T-Cond}}
		\QuaternaryInfC{$\ell\cdot\Gamma_1+\Gamma_2\vdash\cond{t_1}{t_2}{t_3}:T$}
	\end{prooftree}
	
	\begin{prooftree}
		\AXC{}
		\RightLabel{\textsc{T-Zero}}
		\UIC{$\srzero\cdot\Gamma\vdash0:\nat$}
	\end{prooftree}
	
	\begin{prooftree}
		\AXC{$\Gamma\vdash t:\nat$}
		\RightLabel{\textsc{T-Succ}}
		\UIC{$\Gamma\vdash\suc t:\nat$}
	\end{prooftree}
	
	\begin{prooftree}
		\AXC{$\Gamma\vdash t:\nat$}
		\RightLabel{\textsc{T-Pred}}
		\UIC{$\Gamma\vdash\prd t:\nat$}
	\end{prooftree}
	
	\begin{prooftree}
		\AXC{$\Gamma\vdash t:\nat$}
		\RightLabel{\textsc{T-IsZero}}
		\UIC{$\Gamma\vdash\iszero t:\bool$}
	\end{prooftree}
	
	\begin{prooftree}
		\AXC{}
		\RightLabel{\textsc{T-Unit}}
		\UIC{$\srzero\cdot\Gamma\vdash\unt:\untt$}
	\end{prooftree}
	
	\begin{prooftree}
		\AXC{$\Gamma_1\vdash t_1:\untt$}
		\AXC{$\Gamma_2\vdash t_2:T$}
		\RightLabel{\textsc{T-UnitElim}}
		\BIC{$\Gamma_1+\Gamma_2\vdash\une{t_1}{t_2}:T$}
	\end{prooftree}
	\caption{Typing Rules for Built-in Booleans, Integers, etc.}
\end{figure}

A noteworthy point of these rules is the premise $\ell\sqsubseteq 1$ of rule \textsc{T-Cond}. This requirement is added to prevent the \emph{control flow attack} via \emph{implicit flow}, in which the attacker uses some form of equality checking and control flow to leak information. For example, the following typing derivation is invalid in our system:

\begin{prooftree}
	\def\defaultHypSeparation{\hskip .03in}
	\AXC{$x:[\bool]_\public\vdash x:\bool$}
	\AXC{$\vdash 0:\nat$}
	\AXC{$\vdash 42:\nat$}
	\AXC{$\secret\sqsubseteq\srone$}
	\QuaternaryInfC{$x:[\bool]_\secret\vdash\cond{x}{0}{42}:\nat$}
\end{prooftree}

This is the same solution in Abel and Bernardy \cite{abel2020unified} and Choudhury et al. \cite{choudhury2021graded}.

\subsection{Operational Semantics}

Once the type-checker shows that a program is well-typed, the AST is interpreted to execute following a standard call-by-value evaluation strategy. To make proving the \hyperref[thm-pre]{type preservation theorem} more easy, we specify the operational semantics of \textsc{FlowSTLC} in the small-step style. We first specify the value as lambda abstractions and literals:

\begin{figure}[H]
	\centering
	$$
	\textsf{Value}\; v\;::=\;\lam{x\colon T}{t}\;|\; n\;|\; \true\;|\; \false \;|\;\unt
	$$
	\caption{Value of \textsc{FlowSTLC}}
\end{figure}

The call-by-value reduction relation $t\to t'$ is then defined as follows:

\begin{figure}[H]
	\centering
	\begin{prooftree}
		\AXC{$t_1\reduce t_1'$}
		\RightLabel{\textsc{E-App1}}
		\UIC{$t_1\; t_2\reduce t_1'\; t_2$}
	\end{prooftree}
	
	\begin{prooftree}
		\AXC{$t_2\reduce t_2'$}
		\RightLabel{\textsc{E-App2}}
		\UIC{$v_1\; t_2\reduce v_1\; t_2'$}
	\end{prooftree}
	
	\begin{prooftree}
		\AXC{}
		\RightLabel{\textsc{E-AppAbs}}
		\UIC{$(\lam{x:T}{t})\; v\reduce [x\mapsto v]t$}
	\end{prooftree}
	
	\begin{prooftree}
		\AXC{$t\reduce t'$}
		\RightLabel{\textsc{E-Pro}}
		\UIC{$[t]\reduce[t']$}
	\end{prooftree}
	
	\begin{prooftree}
		\AXC{$t_1\reduce t_1'$}
		\RightLabel{\textsc{E-Let-Eval}}
		\UIC{$\unp{x}{t_1}{t_2}\reduce\unp{x}{t_1'}{t_2}$}
	\end{prooftree}
	
	\begin{prooftree}
		\AXC{}
		\RightLabel{\textsc{E-Let-Unbox}}
		\UIC{$\unp{x}{[v]}{t}\reduce [x\mapsto v]t$}
	\end{prooftree}
	\caption{Core Evaluation Rules of \textsc{FlowSTLC}}
\end{figure}

The operational behavior of primitive values, functions, and conditionals is then specified in a intuitive manner:

\begin{figure}[H]
	\centering
	\begin{prooftree}
		\AXC{$t_1\reduce t_1'$}
		\RightLabel{\textsc{E-If-Eval}}
		\UIC{$\cond{t_1}{t_2}{t_3}\reduce\cond{t_1'}{t_2}{t_3}$}
	\end{prooftree}
	
	\begin{prooftree}
		\AXC{}
		\RightLabel{\textsc{E-If-True}}
		\UIC{$\cond{\true}{t_2}{t_3}\reduce t_2$}
	\end{prooftree}
	
	\begin{prooftree}
		\AXC{}
		\RightLabel{\textsc{E-If-False}}
		\UIC{$\cond{\false}{t_2}{t_3}\reduce t_3$}
	\end{prooftree}
	
	\begin{prooftree}
		\AXC{$t_1\reduce t_1'$}
		\RightLabel{\textsc{E-Unit-Elim-Eval}}
		\UIC{$\une{t_1}{t_2}\reduce\une{t_1'}{t_2}$}
	\end{prooftree}
	
	\begin{prooftree}
		\AXC{}
		\RightLabel{\textsc{E-Unit-Elim}}
		\UIC{$\une{\unt}{t}\reduce t$}
	\end{prooftree}
	
	\begin{prooftree}
		\AXC{$t\reduce t'$}
		\RightLabel{\textsc{E-Succ}}
		\UIC{$\suc{t}\reduce\suc{t'}$}
	\end{prooftree}
	
	\begin{prooftree}
		\AXC{$t\reduce t'$}
		\RightLabel{\textsc{E-Pred}}
		\UIC{$\prd{t}\reduce\prd{t'}$}
	\end{prooftree}
	
	\begin{prooftree}
		\AXC{$t\reduce t'$}
		\RightLabel{\textsc{E-IsZero}}
		\UIC{$\iszero{t}\reduce\iszero{t'}$}
	\end{prooftree}
	
	\begin{prooftree}
		\AXC{}
		\RightLabel{\textsc{E-Pred-Zero}}
		\UIC{$\prd 0\reduce 0$}
	\end{prooftree}
	
	\begin{prooftree}
		\AXC{}
		\RightLabel{\textsc{E-Pred-Succ}}
		\UIC{$\prd{\suc t}\reduce t$}
	\end{prooftree}
	
	\begin{prooftree}
		\AXC{}
		\RightLabel{\textsc{E-IsZero-Zero}}
		\UIC{$\iszero 0\reduce\true$}
	\end{prooftree}
	
	\begin{prooftree}
		\AXC{}
		\RightLabel{\textsc{E-IsZero-Succ}}
		\UIC{$\iszero{\suc t}\reduce\false$}
	\end{prooftree}
	\caption{Evaluation Rules for Built-in Booleans, Integers, etc.}
\end{figure}

\subsection{Graded Modality}

The central innovation of \textsc{FlowSTLC} is the use of a graded modality $\gradedt{\ell}{T}$ to track and control information flow. This modality is parameterized by a security grade $\ell$ drawn from the semiring $\secure$, where the ordering signifies that $\secret$ information is more sensitive than $\public$.

Intuitively, a term of type $\gradedt{\ell}{T}$ is a value that should be used according to some security policies, the grade $\ell$ attached to the modality acts as a capability or a requirement: it specifies the minimum security level of the context necessary to "unbox" and use the value.

The power of this approach lies in the algebraic structure of the security semiring. The semiring operations (meet for addition, join for multiplication) naturally model the combination of security constraints:

\begin{itemize}
	\item \textbf{Context Concatenation} uses the join operation ($\sqcap$) to combine graded assumptions for the same variable. This reflects the principle that if a value can be used publicly, them it should also can be used secretly elsewhere. For example, using a variable in two different parts of a program, one requiring $\secret$ and the other $\public$, results in a combined requirement of $\public$ ($\secret\sqcap\public = \public$).
	
	\item \textbf{Context Scalar Multiplication} uses the meet operation ($\sqcup$). to strengthen the security requirements of a context. This is crucial in the \textsc{T-Pro} rule for ensuring that a promoted term does not leak its contents to a lower grade.
\end{itemize}

In essence, the graded modality $\gradedt{\ell}{T}$ serves as a security-aware container. The type system's rules ensure that the "capability" $\ell$ needed to open this container is always respected, thereby statically guaranteeing that high-sensitivity data cannot flow into low-sensitivity outputs.

\subsection{A Simple Example}

We demonstrate the system's capability of enforcing noninterferencee by showing the system would reject the following program:
$$
\lam{x:\gradedt{\secret}{T}}{\textbf{let }[y]=x\textbf{ in }y}:\gradedt{\secret}{T}\to^\public T
$$

since it try to use a $\secret$ value to compute a $\public$ value. To type this term, we first need to show that
$$
x:[\gradedt{\secret}{T}]_\public\vdash \textbf{let }[y]=x\textbf{ in }y:\gradedt{\secret}{T}\to^\public T
$$

then according to the premises of \textsc{T-Let} rule, we need to show the following
\begin{enumerate}
	\item $x:[\gradedt{\secret}{T}]_\public\vdash x:\gradedt{\secret}{T}$ 
	\item $y:[T]_\secret\vdash y:T$
\end{enumerate}

The (1) is trivial to show, but there is no rule that allows the derivation of (2). \textsc{T-Var} rule doesn't help here because it requires that the used variable must have a $\public$ grade. So the term is ill-typed.

\section{Metatheory}
\subsection{Type Safety}
\label{lem-perm}
\begin{lemma}[Permutation]
	If $\Gamma\vdash t:T$ and $\Delta$ is a permutation of $\Gamma$, then $\Delta\vdash t:T$ and the derivation depth of the latter is the same as the former.
\end{lemma}
The proof for the permutation lemma is trivial since assumptions in contexts are unrelated in a simply-typed context. Then we prove the well-typedness of substitution, this lemma is then used to establish syntactic type safety.
\begin{lemma}[Well-typed Substitution] 
	If $\Gamma_1\vdash t_1:T_1$ and $\Gamma_2,x:[T_1]_\ell\vdash t_2:T_2$, then we have $\Gamma_1+\ell\cdot\Gamma_2\vdash[x\mapsto t_1]t_2:T_2$.
\end{lemma}
We then state the type safety lemma as follows:
\label{thm-type-safety}
\begin{theorem}[Type Preservation]
	If $\Gamma\vdash t:T$, then either $t$ is a value or there exists a $t'$ s.t. $t\rightsquigarrow t'$ with $\Gamma\vdash t:T$.
\end{theorem}

\subsection{Strong Normalization}
\label{thm-sn}
\begin{theorem}[Strong Normalization]
	If $t$ is a closed and well-typed \text{FlowSTLC} term, then $t$ is normalizable.
\end{theorem}

\subsection{Fundamental Theorems and Noninterference}

Our definition of type semantics by building a logical relation model following the work of Rajani et al. \cite{rajani2018types}. The key difference between our approach and the work of Rajani et al. is that our calculus use a coeffect-based analysis instead of effect-based analysis. 

We first define a type-indexed unary relation $\llbracket T\rrbracket_\calv$ which captures the set of irreducible terms that inhabit type $T$. The relation is formally defined as a set of mutually inductive definitions:

\begin{figure}[H]
	\centering
	$$
	\begin{aligned}
		\llbracket T\rrbracket_\calv &= \{t\mid t\rightsquigarrow^* v\implies v\in[A]_\calv\}\\
		\llbracket\untt\rrbracket_\calv &= \{ \unt \} \\
		\llbracket\bool\rrbracket_\calv &= \{\true, \false\} \\
		\llbracket\nat\rrbracket_\calv &= \{n \mid n \in \mathbb{N}\} \\
		\llbracket T_1\to^\ell T_2 \rrbracket_\calv &= \{\lambda x.t \mid \forall v.[v]\in\llbracket\gradedt{\ell}{T_1}\rrbracket_\cale\implies\\ &\qquad[x\mapsto v]t\in\llbracket T_2\rrbracket_\cale\} \\
		\llbracket\gradedt{\ell}{T}\rrbracket_\calv &= \{[t] \mid t\rightsquigarrow^* v\implies v \in \llbracket T \rrbracket_\cale\}\\
		\llbracket\Gamma\rrbracket&=\{\gamma\mid x:[T]_\ell\wedge[\gamma(x)]\in \llbracket\gradedt{\ell}{T}\rrbracket_\cale\}
	\end{aligned}
	$$
	\caption{Unary value, expression, and context relations}
\end{figure}

For the function type $T_1\to^\ell T_2$, the value inhabiting its interpretation are abstractions $\lambda x.t$ where the substitution of value $v$ into the body $t$ is in the interpretation of the expression relation at the result type. The interpretation of the graded modal type $\gradedt{\ell}{T}$ is the set of values which are the promotions of terms in the interpretation $T$. Finally, the $\llbracket\Gamma\rrbracket$ relation defines an interpretation of the context $\Gamma$ as a set of maps from variables to expressions (denoted by $\gamma$) that can be substituted for each variable.

We also define a binary relation which captures \emph{indistinguishability} from the perspective of an adversary level $adv\in\secure$. The relation is formally defined by the following figure:

\begin{figure}[H]
	\centering
	
	\caption{Binary value, expression, and context relations}
\end{figure}

\section{Bidirectional Type Checking Algorithm}

\section{Implementation and Examples}

\section{Related Work}

Language-based IFC has a rich literature. Sabelfeld and Myers \cite{sabelfeld2003language} survey a variety of security type systems that enforce noninterference via typing. Seminal work by Volpano et al. \cite{volpano1996sound} introduced a static type system for a simple imperative language, ensuring well-typed programs satisfy noninterference. Extensions include JFlow \cite{myers1999jflow} and JIF \cite{pullicino2014jif} for Java, which associate security labels with Java types to track flows, and FlowCaml \cite{simonet2003flow} for OCaml, which similarly adds a security type-checker. Generally, these systems label each variable as high or low and enforce rules so that no operation can use a high value in a low context.

More recently, graded type theories have been proposed to generalize such analyses. Graded type systems annotate types with additional information ("grades") to capture various properties of programs. For example, the Granule language \cite{orchard2019quantitative} uses graded modalities to track the effects and coeffects of program. In information flow use-cases, types are graded by a security lattice, allowing automatic enforcement of noninterference. Moon et al. introduce the Graded Modal Dependent Type Theory (\textsc{GrTT}) \cite{moon2021graded}, which extends dependent type system with graded modality and show that the grades can be effective at reasoning of programs. This work demonstrates that graded modality can capture fine-grained flow policies in types. Similarly, Marshall and Orchard \citen{marshall2023graded} demonstrated a graded-modal framework that can enforce confidentiality and even integrity simultaneously.

Other approaches include dynamic IFC (e.g. LIO monad in Haskell \cite{stefan2011flexible}) or hybrid systems, but our focus is purely static. In summary, while classical security type sytems (JIF, FlowCaml, etc.) enforce noninterference via fixed lattice-labels. Our project draws on these ideas: we adapt graded modalities to a simple functional language to track information flows more flexibly.

\section{Further Work and Conclusion}

In summary, \textsc{FlowSTLC} has demonstrated that a simple lambda calculus with graded necessity can enforce secure information flow. By instantiating grades with the  security semiring $\secure$, our system statically tracks data labels at the type level. And with typing rules that enforcing the noninterference property, we guarantee that well-typed \textsc{FlowSTLC} programs cannot leak secrets. 

Despite these positive results, \textsc{FlowSTLC} in its current form is an \emph{idealized model} with clear limitations. For one, the core calculus is deliberately small and omits many practical language features. It has only base types and functions (no records, no algebraic data types, no recursive types, etc.), and it does not include polymorphism or dependent typing. As observed in prior work, static IFC models with minimal features have historically been considered "too limited or too restrictive to be used in practice" \cite{myers1999jflow}. Thus, our model inherits this limitation of expressiveness. Second, \textsc{FlowSTLC} exists only as a theoretical calculus and has not been integrated into a full-blown programming language. We consider that bridging this gap is a non-trivial challenge. For example, a recent survey noted that even in a rich language like Rust, implementing a sound IFC system requires "building an ad-hoc effect tracking system using bleeding-edge features of the Rust compiler". Finally, we have not evaluated performance or conducted real-world case studies. There are no benchmarks on typing or runtime costs, nor have we applied \text{FlowSTLC} to any non-trivial programs. In contrast, systems like JFlow and Cocoon \cite{lamba2024cocoon} have shown that static IFC checking can incur negligible overhead. Without such evaluation, the practical impact of \textsc{FlowSTLC} remains speculative.

Given these limitations, there are many promising directions for future work. We highlight several concrete directions:
\begin{itemize}
    \item \textbf{Extending the type system with dependent types and polymorphism.} One natural extension is to enrich \textsc{FlowSTLC} with more expressive typing disciplines. In particular, adding \emph{dependent types} could allow security policies to depend on program values and thus encode more precise confidentiality and declassification properties. Prior work (e.g. DepSec for Idris language \cite{gregersen2019dependently}) shows that dependent types increase the expressiveness of static IFCs. Similarly, introducing \emph{parametric polymorphism} would permit writing generic secure functions without duplicating code.
    \item \textbf{Combining graded modalities with effect, usage, or resource typing.} Another interesting direction is to study how the security grading interacts with other static analyses. Graded type theories generalize both effect systems (via graded monads) and coeffect/usage systems (via graded comonads). For example, \textsc{FlowSTLC} might be extended with an effect system that tracks side-effects or I/O on secret data (similar to Koka's effect typing system \cite{leijen2014koka} \cite{leijen2016algebraic}). Alternatively, one could explore \emph{coeffect-like} analyses where the context is graded alongside security. Integrating graded security labels with \emph{resource-} or \emph{capability-aware typing} could yield richer guarantees.
    \item \textbf{Embedding \textsc{FlowSTLC} in a practical language or compiler.} To bring theory closer to practice, a implementation of \text{FlowSTLC}'s typing discipline in a real programming environment is essential. One approach is to create a domain-specific language (DSL) or library for an existing language (e.g. Haskell or OCaml) that enforces these graded security types. Recent work (e.g. \cite{lamba2024cocoon}) shows that it is possible to add IFC to Rust without modifying the compiler. Similarly, the Granule project \cite{orchard2019quantitative} demonstrates that a language with graded, linear, and dependent types can be realized in practice. Following these examples, we could adapt \textsc{FlowSTLC}'s type checker into an implementation (for instance, a GHC plugin) to test on larger codebases. Such an embedding would enable empirical measurement of type-checking performance and runtime costs. It would also allow exploration of practical issues (language interoperability, tooling integration, etc.) that are vital for any real applications of our outcome.
\end{itemize}

In conclusion, \textsc{FlowSTLC} provides a formal foundation for secure information flow via graded modal types, but many challenges remain. Future work will pursue richer type features, deeper integration with program reasoning (effects, resources), and practical implementation efforts. We are optimistic that bridging these gaps will bring secure flow typing closer to real-world programming. By pursuing these directions, we hope to develop a mature framework that combines the rigorous guarantees of our type-theoretic approach with the expressiveness and practicality needed for deployed systems.

\section*{Acknowledgment}
We would like to express our sincere gratitude to the Theoretical Computer Science StackExchange user taquetgauche, who reviewed our early prototype type systems and provided valuable feedback on how to proceed.

We are also deeply thankful to all members of the Theoretical Computer Science Society of SUSTech for their continued support and for the many insightful ideas they shared with us throughout this project.

\bibliographystyle{IEEEtran}
\bibliography{term_project_report}

\newpage
\appendix

\subsection{Complete Specification of \textsc{FlowSTLC}}
\subsubsection{Syntax}
\begin{center}
	\begin{bnf}
		$t$ : \textsf{Term} ::=
		| $x$ : \textit{variable}
		| $t$ $t$ : \textit{application}
		| $\lam{x}{t}$ : \textit{abstraction}
		| $[t]$ : \textit{packing}
		| $\unp{x}{t\colon T}{t}$ : \textit{unpacking}
		| $\true$ : \textit{true constant}
		| $\false$ : \textit{false constant}
		| $\cond{t}{t}{t}$ : \textit{conditional}
		| $n$ : \textit{natural number}
		| $\iszero{t}$ : \textit{zero test}
		| $\unt$ : \textit{unit}
		| $\une{t}{t}$ : \textit{unit elimination}
		;;
		$n$ : \textsf{Number} ::=
		| $0$ : \textit{zero constant}
		| $\suc{n}$ : \textit{successor}
		| $\prd{n}$ : \textit{predecessor}
		;;
		$T$ : \textsf{Type} ::=
		| \untt : \textit{unit type}
		| \nat : \textit{natural number type}
		| \bool : \textit{boolean type}
		| $T\to^\ell T$ : \textit{function type}
		| $\gradedt{r}{T}$ : \textit{graded modality}
		;;
		$v$ : \textsf{Value} ::=
		| $\lam{x\colon T}{t}$ : \textit{abstraction value}
		| $n$ : \textit{natural number value}
		| $\true$ : \textit{true value}
		| $\false$ : \textit{false value}
		| $\unt$ : \textit{unit value}
		;;
		$\Gamma$ : \textsf{Context} ::=
		| $\emptyset$ : \textit{empty context}
		| $\Gamma,x\colon[T]_r$ : \textit{graded assumption}
		;;
		$\ell$ : \textsf{Security} ::=
		| \secret : \textit{high-security label}
		| \public : \textit{low-security label}
		;;
	\end{bnf}
\end{center}

\subsubsection{Security Level Semiring}

\begin{definition}[Security Level Semiring]
The security level semiring $\mathbb{S}$ is a two-point lattice of security levels $\secure=\{\public\sqsubseteq\secret\}$ with 
\begin{itemize}
	\item $\srzero=\secret$
	\item $\srone=\public$
	\item Addition as the meet: $r+s=r\sqcap s$
	\item Multiplication as the join $r\cdot s=r\sqcup s$
\end{itemize}
\end{definition}
See \hyperref[app-b]{Appendix B} for a proof that this algebra is a indeed a semiring.

\subsubsection{Auxiliary Definitions}
\label{def-concat}
\begin{definition}[Context Concatenation]
    $$
    \begin{aligned}
        \emptyset+\Gamma&=\Gamma\\
        \Gamma+\emptyset&=\Gamma\\
        (\Gamma,x:[T]_r)+(\Gamma',x:[T]_s)&=(\Gamma+\Gamma'),x:[T]_{r+s}
    \end{aligned}
    $$
\end{definition}
\label{def-mul}
\begin{definition}[Context Scalar Multiplication]
    $$
    \begin{aligned}
    r\cdot\emptyset&=\emptyset\\
    r\cdot(\Gamma,x:[T]_s)&=(r\cdot\Gamma),x:[T]_{(r\cdot s)}\\
    \end{aligned}
    $$
\end{definition}

\subsubsection{Typing Rules}

\begin{prooftree}
	\AXC{}
	\RightLabel{\textsc{T-Var}}
	\UIC{$\srzero\cdot\Gamma,x:[T]_\srone\vdash x:T$}
\end{prooftree}

\begin{prooftree}
	\AXC{$\Gamma,x:[T_1]_\ell\vdash t:T_2$}
	\RightLabel{\textsc{T-Abs}}
	\UIC{$\Gamma\vdash\lam{x:T_1}{t}:T_1\to^\ell T_2$}
\end{prooftree}

\begin{prooftree}
	\AXC{$\Gamma_1\vdash t_1:T_{11}\to^\ell T_{12}$}
	\AXC{$\Gamma_2\vdash t_2:T_{11}$}
	\RightLabel{\textsc{T-App}}
	\BIC{$\Gamma_1+\ell\cdot\Gamma_2\vdash t_1\; t_2:T_{12}$}
\end{prooftree}

\begin{prooftree}
	\AXC{$\Gamma\vdash t:T$}
	\RightLabel{\textsc{T-Pro}}
	\UIC{$\ell\cdot\Gamma\vdash[t]:\gradedt{\ell}{T}$}
\end{prooftree}

\begin{prooftree}
	\AXC{$\Gamma_1\vdash t_1:\gradedt{\ell}{T_1}$}
	\AXC{$\Gamma_2,x:[T_1]_\ell\vdash t_2:T_2$}
	\RightLabel{\textsc{T-Let}}
	\BIC{$\Gamma_1+\Gamma_2\vdash\unp{x}{t_1}{t_2}:T_2$}
\end{prooftree}

\begin{prooftree}
	\AXC{$\Gamma,x:[T_2]_{\ell_1}\vdash t:T_1$}
	\AXC{$\ell_2\sqsubseteq\ell_1$}
	\RightLabel{\textsc{T-Approx}}
	\BIC{$\Gamma,x:[T_2]_{\ell_2}\vdash t:T_1$}
\end{prooftree}

\begin{prooftree}
	\AXC{}
	\RightLabel{\textsc{T-True}}
	\UIC{$\srzero\cdot\Gamma\vdash\true:\bool$}
\end{prooftree}

\begin{prooftree}
	\AXC{}
	\RightLabel{\textsc{T-False}}
	\UIC{$\srzero\cdot\Gamma\vdash\false:\bool$}
\end{prooftree}

\begin{prooftree}
	\def\defaultHypSeparation{\hskip .03in}
	\AXC{$\Gamma_1\vdash t_1:\bool$}
	\AXC{$\Gamma_2\vdash t_2:T$}
	\AXC{$\Gamma_2\vdash t_3:T$}
	\AXC{$\ell\sqsubseteq\srone$}
	\RightLabel{\textsc{T-Cond}}
	\QuaternaryInfC{$\ell\cdot\Gamma_1+\Gamma_2\vdash\cond{t_1}{t_2}{t_3}:T$}
\end{prooftree}

\begin{prooftree}
	\AXC{}
	\RightLabel{\textsc{T-Zero}}
	\UIC{$\srzero\cdot\Gamma\vdash0:\nat$}
\end{prooftree}

\begin{prooftree}
	\AXC{$\Gamma\vdash t:\nat$}
	\RightLabel{\textsc{T-Succ}}
	\UIC{$\Gamma\vdash\suc t:\nat$}
\end{prooftree}

\begin{prooftree}
	\AXC{$\Gamma\vdash t:\nat$}
	\RightLabel{\textsc{T-Pred}}
	\UIC{$\Gamma\vdash\prd t:\nat$}
\end{prooftree}

\begin{prooftree}
	\AXC{$\Gamma\vdash t:\nat$}
	\RightLabel{\textsc{T-IsZero}}
	\UIC{$\Gamma\vdash\iszero t:\bool$}
\end{prooftree}

\begin{prooftree}
	\AXC{}
	\RightLabel{\textsc{T-Unit}}
	\UIC{$\srzero\cdot\Gamma\vdash\unt:\untt$}
\end{prooftree}

\begin{prooftree}
	\AXC{$\Gamma_1\vdash t_1:\untt$}
	\AXC{$\Gamma_2\vdash t_2:T$}
	\RightLabel{\textsc{T-UnitElim}}
	\BIC{$\Gamma_1+\Gamma_2\vdash\une{t_1}{t_2}:T$}
\end{prooftree}

\subsubsection{Evaluation Rules}

\begin{prooftree}
	\AXC{$t_1\reduce t_1'$}
	\RightLabel{\textsc{E-App1}}
	\UIC{$t_1\; t_2\reduce t_1'\; t_2$}
\end{prooftree}

\begin{prooftree}
	\AXC{$t_2\reduce t_2'$}
	\RightLabel{\textsc{E-App2}}
	\UIC{$v_1\; t_2\reduce v_1\; t_2'$}
\end{prooftree}

\begin{prooftree}
\AXC{}
\RightLabel{\textsc{E-AppAbs}}
\UIC{$(\lam{x:T}{t})\; v\reduce [x\mapsto v]t$}
\end{prooftree}

\begin{prooftree}
	\AXC{$t\reduce t'$}
	\RightLabel{\textsc{E-Pro}}
	\UIC{$[t]\reduce[t']$}
\end{prooftree}

\begin{prooftree}
	\AXC{$t_1\reduce t_1'$}
	\RightLabel{\textsc{E-Let-Eval}}
	\UIC{$\unp{x}{t_1}{t_2}\reduce\unp{x}{t_1'}{t_2}$}
\end{prooftree}

\begin{prooftree}
	\AXC{}
	\RightLabel{\textsc{E-Let-Unbox}}
	\UIC{$\unp{x}{[v]}{t}\reduce [x\mapsto v]t$}
\end{prooftree}

\begin{prooftree}
	\AXC{$t_1\reduce t_1'$}
	\RightLabel{\textsc{E-If-Eval}}
	\UIC{$\cond{t_1}{t_2}{t_3}\reduce\cond{t_1'}{t_2}{t_3}$}
\end{prooftree}

\begin{prooftree}
	\AXC{}
	\RightLabel{\textsc{E-If-True}}
	\UIC{$\cond{\true}{t_2}{t_3}\reduce t_2$}
\end{prooftree}

\begin{prooftree}
	\AXC{}
	\RightLabel{\textsc{E-If-False}}
	\UIC{$\cond{\false}{t_2}{t_3}\reduce t_3$}
\end{prooftree}

\begin{prooftree}
	\AXC{$t_1\reduce t_1'$}
	\RightLabel{\textsc{E-Unit-Elim-Eval}}
	\UIC{$\une{t_1}{t_2}\reduce\une{t_1'}{t_2}$}
\end{prooftree}

\begin{prooftree}
	\AXC{}
	\RightLabel{\textsc{E-Unit-Elim}}
	\UIC{$\une{\unt}{t}\reduce t$}
\end{prooftree}

\begin{prooftree}
	\AXC{$t\reduce t'$}
	\RightLabel{\textsc{E-Succ}}
	\UIC{$\suc{t}\reduce\suc{t'}$}
\end{prooftree}

\begin{prooftree}
	\AXC{$t\reduce t'$}
	\RightLabel{\textsc{E-Pred}}
	\UIC{$\prd{t}\reduce\prd{t'}$}
\end{prooftree}

\begin{prooftree}
	\AXC{$t\reduce t'$}
	\RightLabel{\textsc{E-IsZero}}
	\UIC{$\iszero{t}\reduce\iszero{t'}$}
\end{prooftree}

\begin{prooftree}
	\AXC{}
	\RightLabel{\textsc{E-Pred-Zero}}
	\UIC{$\prd 0\reduce 0$}
\end{prooftree}

\begin{prooftree}
	\AXC{}
	\RightLabel{\textsc{E-Pred-Succ}}
	\UIC{$\prd{\suc t}\reduce t$}
\end{prooftree}

\begin{prooftree}
	\AXC{}
	\RightLabel{\textsc{E-IsZero-Zero}}
	\UIC{$\iszero 0\reduce\true$}
\end{prooftree}

\begin{prooftree}
	\AXC{}
	\RightLabel{\textsc{E-IsZero-Succ}}
	\UIC{$\iszero{\suc t}\reduce\false$}
\end{prooftree}

\subsection{Proofs}
\subsubsection{Security Level Semiring}
\label{app-b}
\begin{proof}\leavevmode
	\begin{itemize}
		\item \textbf{Associativity of addition}: $(a+b)+c=a+(b+c)$
		
		This is trivial since the semiring addition is meet, and join is associative in a lattice.
		\item \textbf{Commutativity of addition}: $a+b=b+a$
		
		This is also trivial since meet is commutative in a lattice.
		\item \textbf{Additive identity}: $a+\srzero=a$ for all $a$
		
		Since $0=\secret$, and $\secret$ be the maximum in $\secure$, we have
		\begin{equation}
			\begin{aligned}
				\secret\sqcap\secret&=\secret\\
				\public\sqcap\secret&=\public\\	
			\end{aligned}
		\end{equation}
		\item \textbf{Associativity of multiplication}: $(a\cdot b)\cdot c=a\cdot (b\cdot c)$
		
		This is trivial by the associativity of join operation.
		
		\item \textbf{Multiplication distributes over addition}: $a\cdot(b+c)=(a\cdot b)+(a\cdot c)$ and $(a+b)\cdot c=(a\cdot c)+(b\cdot c)$
		
		The distributivity trivially holds since $\secure$ is a two-point lattice.
		
		\item \textbf{Multiplicative identity}: $a\cdot\srone=a$ for all $a$
		
		Since $1=\public$ and $\public\sqsubset\secret$, we have
		\begin{equation}
			\begin{aligned}
				\public\sqcup\public&=\public\\
				\public\sqcup\secret&=\secret\\
			\end{aligned}
		\end{equation}
		\item \textbf{Multiplication by 0 annihilates}: $\srzero\cdot a=a\cdot\srzero=\srzero$ for all $a$
		
		Since $0=\secret$ and $\public\sqsubset\secret$, we have
		\begin{equation}
			\begin{aligned}
				\secret\sqcup\secret&=\secret\\
				\public\sqcup\secret&=\secret\\
			\end{aligned}
		\end{equation}
	\end{itemize}
	Thus the security level algebra is a semiring.
\end{proof}

\subsubsection{Well-typed substitution}
\begin{proof}
	By induction on a derivation of the form $\Gamma,x:[T_1]_\ell\vdash t_2:T_2$. For a given derivation, we proceed by cases on the final typing rule used in the proof.
	\begin{itemize}		
		\item\textbf{Case} \textsc{T-Var}: $t_2=z$ with $z:T_1\in(\Gamma,x:[T_1]_\ell)$
		
		We need to consider two subcases: 
		\begin{enumerate}
			\item if $z=x$, then $[x\mapsto t_1]z=t_1$, 
		\end{enumerate}	
		
		\item\textbf{Case} \textsc{T-Abs}: $t=\lam{y:T_2}{t_1}$, $T=T_2\to T_1$, $\Gamma,x:S,y:T_2\vdash t_1:T_1$
		
		By convention we may assume that $x\ne y$ and $y\notin FV(s)$. Then by the permutation lemma and weakening rule, we have $\Gamma,\Delta,y:T_2,x:S\vdash t_1:T_1$. Again we apply the two rules on the assumption $\Delta\vdash s:S$ to get $\Gamma,\Delta,y:T_2\vdash s:S$. By the induction hypothesis, we have $\Gamma,\Delta,y:T_2\vdash [x\mapsto s]t_1:T_1$, then by \textsc{T-Abs} $\Gamma,\Delta\vdash \lam{y:T_2}{[x\mapsto s]t_1}:T_2\to T_1$, and this is our desired result.
		
		\item\textbf{Case} \textsc{T-App}: $t=t_1\; t_2$, $\Gamma,x:S\vdash t_1:T_2\to T_1$, $\Gamma,x:S\vdash t_2:T_2$, $T=T_1$
		
		By the induction hypothesis, we have $\Gamma,\Delta\vdash [x\mapsto s]t_1:T_2\to T_1$ and $\Gamma,\Delta\vdash [x\mapsto s]t_2:T_2$. Then by \textsc{T-App}, $\Gamma,\Delta\vdash [x\mapsto s]t_1\; [x\mapsto s]t_2:T_1$, i.e., $\Gamma,\Delta\vdash [x\mapsto s](t_1\; t_2):T_1$.
		
		\item\textbf{Case} \textsc{T-Weak}: $t=t_1$, $\Gamma'\vdash t_1:T$ where $\Gamma'\subseteq(\Gamma,x:S)$ and $x:S\in\Gamma'$
		
		By the induction hypothesis, we have $\Gamma',\Delta\vdash [x\mapsto s]t_1:T$, then apply the \textsc{T-Weak}, we have $\Gamma,\Delta\vdash [x\mapsto s]t_1:T$.
		
		\item\textbf{Case} \textsc{T-Der}: $t=t_1$, $T=T_1$, $\Gamma,x:S,y:T_2\vdash t_1:T_1$
		
		By the induction hypothesis and permutation lemma, we have $\Gamma,\Delta,y:T_2\vdash [x\mapsto s]t_1:T_1$. Then by the \text{T-Der} rule, we immediately have our desired result $\Gamma,\Delta,y:[T_2]_\public\vdash [x\mapsto s]t_1:T_1$.
		
		\item\textbf{Case} \textsc{T-Pro}:
		
		This case is impossible since \textsc{T-Pro} rule requires a purely graded context, and $x:S$ would violate the premise.
		
		\item\textbf{Case} \textsc{T-Let}: $t=\unp{y}{t_1}{t_2}$, $\Gamma_1,x:S\vdash t_1:\gradedt{\ell}{T_1}$, $\Gamma_2,y:[T_1]_\ell,x:S\vdash t_2:T_2$, $T=T_2$
		
		Again by convention we may assume that $x\ne y$ and $y\notin FV(s)$. First we apply the induction hypothesis to get $\Gamma_1,\Delta\vdash [x\mapsto s]t_1:\gradedt{\ell}{T_1}$ and $\Gamma_2,\Delta,y:[T_1]_\ell\vdash [x\mapsto s]t_2:T_2$. And it follows from the \textsc{T-Let} rule that $(\Gamma_1+\Gamma_2),\Delta\vdash\unp{y}{[x\mapsto s]t_1}{[x\mapsto s]t_2}:T_2$, i.e., $(\Gamma_1+\Gamma_2),\Delta\vdash[x\mapsto s](\unp{y}{t_1}{t_2}):T_2$.
		
		\item\textbf{Case} \textsc{T-Approx}: $t=t_1$, $\Gamma,x:S,y:[T_2]_{\ell_1}\vdash t_1:T_1$, $\ell_1\sqsubseteq\ell_2$, $T=T_1$.
		
		From the induction hypothesis and permutation lemma we can get $\Gamma,\Delta,y:[T_2]_{\ell_1}\vdash[x\mapsto s]t_1:T_1$. Then we apply the \textsc{T-Approx} rule to get our desired result $\Gamma,\Delta,y:[T_2]_{\ell_2}\vdash[x\mapsto s]t_1:T_1$.
	\end{itemize}
\end{proof}

\subsubsection{Well-typed Graded Substitution}
\begin{proof}
	Similar to how we prove the regular substitution lemma, we proceed by induction on a derivation of the form $\Gamma,x:[S]_\ell\vdash t:T$.
    \begin{itemize}
        \item \textbf{Case} \textsc{T-Var}: $t=z$ with $z:T\in(\Gamma,x:[S]_\ell)$
        
        Unlike the case for regular substitution lemma, $z$ cannot be $x$ since there is not rule that can introduce $\Gamma,\ell\cdot\Delta\vdash s:S$. So $z\ne x$, and we have $[x\mapsto s]z\to z$, and the result is immediate.
        \item \textbf{Case} \textsc{T-Abs}: $t=\lam{y:T_2}{t_1}$, $T=T_2\to T_1$, $\Gamma,x:[S]_\ell,y:T_2\vdash t_1:T_1$
        
        By convention we may assume that $x\notin FV(s)$. Then by
        \item \textbf{Case} \textsc{T-App}:
        \item \textbf{Case} \textsc{T-Weak}:
        \item \textbf{Case} \textsc{T-Der}:
        \item \textbf{Case} \textsc{T-Pro}:
        \item \textbf{Case} \textsc{T-Let}:
        \item \textbf{Case} \textsc{T-Approx}:
    \end{itemize}
\end{proof}

\subsubsection{Type Preservation}
\begin{proof}
	
\end{proof}
\end{document}
