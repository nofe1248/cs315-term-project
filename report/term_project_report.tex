\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts,amsthm}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{simplebnf}
\usepackage{bussproofs}
\usepackage[colorlinks]{hyperref}
\EnableBpAbbreviations
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\newcommand\lam[2]{\lambda #1.#2}
\newcommand\unp[3]{\textbf{let }[#1]=#2\textbf{ in }#3}
\newcommand\gradedt[2]{\square_#1 #2}
\newcommand\public{\texttt{Public}}
\newcommand\secret{\texttt{Secret}}
\newcommand\irrele{\texttt{Irrelevant}}
\newcommand\secure{\mathbb{S}}

\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\begin{document}

\title{\textsc{FlowSTLC}: An Information Flow Control Type System Based On Graded Modality
}

\author{\IEEEauthorblockN{1\textsuperscript{st} Zhige Chen}
\IEEEauthorblockA{\textit{Dept. of Computer Science}\\\textit{and Engineering} \\
\textit{Southern University of}\\\textit{Science and Technology}\\
Shenzhen, China \\
12413315@mail.sustech.edu.cn}
\and
\IEEEauthorblockN{2\textsuperscript{nd} Junqi Huang}
\IEEEauthorblockA{\textit{Dept. of Computer Science}\\\textit{and Engineering} \\
\textit{Southern University of}\\\textit{Science and Technology}\\
Shenzhen, China \\
12212226@mail.sustech.edu.cn}
\and
\IEEEauthorblockN{3\textsuperscript{rd} Zhiyuan Cao}
\IEEEauthorblockA{\textit{Dept. of Computer Science}\\\textit{and Engineering} \\
\textit{Southern University of}\\\textit{Science and Technology}\\
Shenzhen, China \\
12311109@mail.sustech.edu.cn}
}

\maketitle

\begin{abstract}
In this project, we introduce the design and implementation of a simple functional programming language with a type system that enforces secure information flow. Building on the simply-typed lambda calculus (STLC), we extend the type system with a graded modality with a security semiring. Inspired by \textit{Graded Modal Dependent Type Theory} \cite{moon2021graded}, our system statically prevents unauthorized flows of sensitive data into public outputs, ensuring the noninterference property \cite{smith2007principles}.
\end{abstract}

\begin{IEEEkeywords}
Computer security, information flow, noninterference, security-type systems
\end{IEEEkeywords}

\section{Introduction}

Modern software often handles sensitive data that must remain confidential. The \emph{informational flow control} (or IFC) aims to ensure that high-security inputs of the program do not improperly influence low-security outputs. For example, private user information like passwords should never be leaked to public logs. Formally, the security policy of \emph{noninterference} requires that variations in high-security inputs have no observable effect on low-security outputs. Intuitively, this means that changing a secret value should never cause any change in what an outside observer at low level sees. Violating the IFC principle can lead to information leak, so enforcing noninterference is critical for system security.

Type systems \cite{sabelfeld2003language} have been proved effective at enforcing noninterference: they associate each value with aa security label and constrain operations so that a well-typed program is guaranteed not to leak high-security information. For example, a simple rule is that the result of a computation must have the hightest security label of any input used in its computation. If a low-security result depends on a high-security input, the type system would reject the program. Thus, those security type systems can automatically verify that programs adhere to confidentiality policies.

However, existing IFC type systems can be rather inflexible or coarse-grained. Many system treat security labels in a rigid, lattice-based way \cite{denning1976lattice}, and often difficult to coexist with other sophisticated type system constructs. To address these issues, we propose the \textsc{FlowSTLC}, a more flexible and extensible type system that track informational flows with \emph{graded modalities}. More specifically, we will design a simply typed lambda-calculus with integrated \emph{graded necessity} for the semiring $\{\irrele\sqsubseteq\secret\sqsubseteq\public\}$. This system will allow us precisely control how the values interact as a type of coeffects, while remain easy to extend with other program reasoning constructs like the \emph{usage analysis} \cite{orchard2019quantitative}.

\section{\textsc{FlowSTLC}: The Core Calculus}
\subsection{Syntax}

The \textsc{FlowSTLC} is a graded extension to the simply typed lambda-calculus resembling the Fuzz type system of Reed \emph{et al.} \cite{reeddistance}. It is also similar to coeffect calculi of Brunel \emph{et al.} \cite{brunel2014core} and Gaboardi \emph{et al.} \cite{gaboardi2016combining}.

The syntax of \textsc{FlowSTLC} is a straightforward extension of STLC with two additional constructs for introducing and eliminating the graded necessity type $\gradedt{\ell}{T}$:

$$
\begin{aligned}
	\textsf{Term}\;t\;&::=\;x\;|\;t\; t\;|\;\lambda x.t\;|\;[t]\;|\;\textbf{let }[x]=t\textbf{ in }t\\
	\textsf{Type}\;T\;&::=\;T\to T\;|\;\square_r T\\
\end{aligned}
$$

The syntax $[t]$ promotes a term to a graded modality, and $\unp{x}{t_1}{t_2}$ eliminate the modalities by checking whether $t_2$ uses $t_1$ w.r.t. its grade, and, if satisfied, "unbox" the modality and substitute it into $t_2$. The graded modality $\gradedt{\ell}{T}$ is a type constructor where $\ell$ comes from the \emph{security level algebra}, i.e., a semiring $\secure=\irrele\sqsubseteq\secret\sqsubseteq\public$.

Typing judgements are of the regular form $\Gamma\vdash t:T$ with the typing contexts of the form:
$$
\textsf{Context}\;\Gamma\;::=\;\emptyset\;|\;\Gamma,x:T\;|\;\Gamma,x:[T]_\ell
$$

Contexts are either empty $\emptyset$, or can be extended with either a regular assumption $x:T$ or a \emph{graded assumption} $x:[T]_\ell$. The regular assumptions can be used exactly the same way as in STLC. For graded assumptions, their grades $\ell$ capture their substructural behavior by describing how can they be used in a term, in this case, the grade capture the security level of information. We will use $dom(\Gamma)$ to denote the variables assigned by context $\Gamma$.

\subsection{Typing}

\textsc{FlowSTLC} has all three standard typing rules of STLC, plus a explicit weakening rule:
\begin{prooftree}
	\AXC{$x:T\in\Gamma$}
	\RightLabel{\textsc{T-Var}}
	\UIC{$\Gamma\vdash x:T$}
\end{prooftree}

\begin{prooftree}
	\AXC{$\Gamma,x:T_1\vdash t:T_2$}
	\RightLabel{\textsc{T-Abs}}
	\UIC{$\Gamma\vdash\lam{x:T_1}{t}:T_1\to T_2$}
\end{prooftree}

\begin{prooftree}
	\AXC{$\Gamma_1\vdash t_1:T_{11}\to T_{12}$}
	\AXC{$\Gamma_2\vdash t_2:T_{11}$}
	\RightLabel{\textsc{T-App}}
	\BIC{$\Gamma_1+\Gamma_2\vdash t_1\; t_2:T_{12}$}
\end{prooftree}

\begin{prooftree}
	\AXC{$\Gamma\vdash t:T$}
	\RightLabel{\textsc{T-Weak}}
	\UIC{$\Gamma,\Gamma'\vdash t:T$}
\end{prooftree}

The exchange rule that allows permutation of contexts is implicit here, instead we enables the permutation by a permutation lemma (see \hyperref[lem-perm]{Permutation lemma}). The only difference with the standard rules is the application rule applies a \emph{context concatenation} $\Gamma_1+\Gamma_2$. The concatenation combines two contexts if they contain disjoint set of regular assumptions. Then the concatenation will combine all regular assumptions together and merge graded assumptions by the semiring addition $+$ (for more information see the \hyperref[def-concat]{Appendix}).

The remaining rules build the structure of the security label semiring and connect the regular assumptions to the graded ones:
\begin{prooftree}
	\AXC{$\Gamma,x:T_1\vdash t:T_2$}
	\RightLabel{\textsc{T-Der}}
	\UIC{$\Gamma,x:[T_1]_\secret\vdash t:T_2$}
\end{prooftree}

\begin{prooftree}
	\AXC{$[\Gamma]\vdash t:T$}
	\RightLabel{\textsc{T-Pro}}
	\UIC{$\ell\cdot[\Gamma]\vdash[t]:\gradedt{\ell}{T}$}
\end{prooftree}
where $[\Gamma]$ denotes a context containing only graded assumptions.

\begin{prooftree}
	\AXC{$\Gamma_1\vdash t_1:\gradedt{\ell}{T_1}$}
	\AXC{$\Gamma_2,x:[T_1]_\ell\vdash t_2:T_2$}
	\RightLabel{\textsc{T-Let}}
	\BIC{$\Gamma_1+\Gamma_2\vdash\unp{x}{t_1}{t_2}:T_2$}
\end{prooftree}

\begin{prooftree}
	\AXC{$\Gamma,x:[T_2]_{\ell_1}\vdash t:T_1$}
	\AXC{$\ell_1\sqsubseteq\ell_2$}
	\RightLabel{\textsc{T-Approx}}
	\BIC{$\Gamma,x:[T_2]_{\ell_2}\vdash t:T_1$}
\end{prooftree}

The \emph{Dereliction} rule \textsc{T-Der} converts a regular assumption to a graded assumption marked with $\secret$, since the assumption is potentially being used by the term $t$. The \emph{Promotion} rule \textsc{T-Pro} "promotes" a regular term $t$ to a graded modality by propagating its resource requirement to the context by a \emph{scalar multiplication} (for complete definition of scalar multiplication, see the \hyperref[def-mul]{Appendix}). The \textsc{T-Let} rule provides a way to eliminate graded modality via substitution, where graded value is "unboxed" and substituted into a graded assumption with matching grades. The context concatenation is also used in the conclusion. Finally, the \emph{approximation} rule \textsc{T-Approx} allows us to "tighten" the requirement if $\ell_1\sqsubseteq\ell_2$.

\subsection{Operational Semantics}

Once the type-checker shows that a program is well-typed, the AST is interpreted to execute following a standard call-by-value evaluation strategy. To make proving the \hyperref[thm-pre]{type preservation theorem} more easy, we specify the operational semantics of \textsc{FlowSTLC} in the small-step style. We first specify the value as lambda abstractions:
$$
\textsf{Value}\; v\;::=\;\lam{x\colon T}{t}
$$

The call-by-value reduction relation $t\to t'$ is then defined as follows:

\begin{prooftree}
	\AXC{$t_1\to t_1'$}
	\RightLabel{\textsc{E-App1}}
	\UIC{$t_1\; t_2\to t_1'\; t_2$}
\end{prooftree}

\begin{prooftree}
	\AXC{$t_2\to t_2'$}
	\RightLabel{\textsc{E-App2}}
	\UIC{$v_1\; t_2\to v_1\; t_2'$}
\end{prooftree}

$$
(\lam{x:T}{t})\; v\to [x\mapsto v]t\quad\textsc{E-AppAbs}
$$

\begin{prooftree}
	\AXC{$t\to t'$}
	\RightLabel{\textsc{E-Pro}}
	\UIC{$[t]\to[t']$}
\end{prooftree}

\begin{prooftree}
	\AXC{$t_1\to t_1'$}
	\RightLabel{\textsc{E-Let-Eval}}
	\UIC{$\unp{x}{t_1}{t_2}\to\unp{x}{t_1'}{t_2}$}
\end{prooftree}

$$
\unp{x}{v}{t}\to [x\mapsto v]t\quad\textsc{E-Let-Unbox}
$$

\subsection{Graded Modality}

The central innovation of \textsc{FlowSTLC} is the use of a graded modality $\gradedt{\ell}{T}$ to track and control information flow. This modality is parameterized by a security grade $\ell$ drawn from the semiring $\secure$, where the ordering signifies that $\secret$ information is more sensitive than $\public$.

Intuitively, a term of type $\gradedt{\ell}{T}$ is a value that should be used according to some security policies, the grade $\ell$ attached to the modality acts as a capability or a requirement: it specifies the minimum security level of the context necessary to "unbox" and use the value.

The power of this approach lies in the algebraic structure of the security semiring. The semiring operations (meet for addition, join for multiplication) naturally model the combination of security constraints:

\begin{itemize}
	\item \textbf{Context Concatenation} uses the join operation ($\sqcap$) to combine graded assumptions for the same variable. This reflects the principle that if a value can be used publicly, them it should also can be used secretly elsewhere. For example, using a variable in two different parts of a program, one requiring $\secret$ and the other $\public$, results in a combined requirement of $\secret$ ($\secret\sqcup\public = \public$).
	
	\item \textbf{Context Scalar Multiplication} also uses the join operation ($\sqcup$) with a exception when one label is $\irrele$. to strengthen the security requirements of a context. This is crucial in the \textsc{T-Pro} rule for ensuring that a promoted term does not leak its contents to a lower grade.
\end{itemize}


In essence, the graded modality $\gradedt{\ell}{T}$ serves as a security-aware container. The type system's rules ensure that the "capability" $\ell$ needed to open this container is always respected, thereby statically guaranteeing that high-sensitivity data cannot flow into low-sensitivity outputs.

\subsection{A Simple Example}

We demonstrate the system's capability of enforcing noninterferencee by showing the system would reject the following program:
$$
\lam{x:\gradedt{\secret}{T}}{\textbf{let }[y]=x\textbf{ in }[y]}:\gradedt{\secret}{T}\to\gradedt{\public}{T}
$$

since it try to use a $\secret$ value to compute a $\public$ value. To type this term, we first need to show that
$$
x:\gradedt{\secret}{T}\vdash \textbf{let }[y]=x\textbf{ in }[y]:\gradedt{\secret}{T}\to\gradedt{\public}{T}
$$

then we need to show the following
\begin{enumerate}
	\item $x:\gradedt{\secret}{T}\vdash x:\gradedt{\secret}{T}$ 
	\item $y:[T]_\secret\vdash [y]:\gradedt{\public}{T}$
\end{enumerate}

The (1) is trivial to show, but to prove the (2) typing judgement we need to use the $\textsf{T-Pro}$ rule on the judgement $y:T\vdash y:T$ (easy to obtain by \textsc{T-Var} rule), which requires us to show
$$
y:[T]_\ell\vdash y:T\quad\text{and}\quad \ell\cdot\texttt{Public}=\texttt{Secret}
$$

which is clearly impossible with $\texttt{Secret}\sqsubseteq\texttt{Public}$.

\section{Metatheory}
\subsection{Substitution}
\label{lem-perm}
\begin{lemma}[Permutation]
	If $\Gamma\vdash t:T$ and $\Delta$ is a permutation of $\Gamma$, then $\Delta\vdash t:T$ and the derivation depth of the latter is the same as the former.
\end{lemma}
The proof for the permutation lemma is trivial since assumptions in contexts are unrelated in a simply-typed context. The permutation lemma enables us to state the two substitution lemmas in a cleaner form, we first prove the well-typedness of substitution through regular assumptions:
\begin{lemma}[Well-typed Substitution] 
	If $\Gamma,x:S\vdash t:T$ and $\Delta\vdash s:S$, then $\Gamma+\Delta\vdash [x\mapsto s]t:T$.
\end{lemma}

\begin{lemma}[Well-typed Graded Substitution] 
	If $\Gamma,x:[S]_\ell\vdash t:T$ and $[\Delta]\vdash s:S$, then $\Gamma+\ell\cdot\Delta\vdash [x\mapsto s]t:T$.
\end{lemma}

\subsection{Type Preservation}
\label{thm-pre}
\begin{theorem}[Type Preservation]
	If $\Gamma\vdash t:T$ and $t\to t'$, then $\Gamma\vdash t':T$
\end{theorem}

\subsection{Progression}
\label{thm-pro}
\begin{theorem}[Progression]
	Suppose $t$ is a closed and well-typed \text{FlowSTLC} term (i.e., $\emptyset\vdash t:T$ for some $T$), then either $t$ is a value or there exists some $t'$ s.t. $t\to t'$.
\end{theorem}

\subsection{Strong Normalization}
\label{thm-sn}
\begin{theorem}[Strong Normalization]
	If $t$ is a closed and well-typed \text{FlowSTLC} term, then $t$ is normalizable.
\end{theorem}

\subsection{Noninterference}
\begin{definition}[Low-equivalence]
	Two terms $t_1$	and $t_2$ are low-equivalent at security level $\ell$, written $t_1\approx_\ell t_2$, if they are identical except for the values of their subterms that have a grade $\ell'$ where $\ell\sqsubseteq\ell'$.	
\end{definition}
\label{thm-noninterference}
\begin{theorem}[Noninterference]
	For a closed and well-typed $\public$-graded term $t$, i.e. $\emptyset\vdash t:\gradedt{\public}{T}$ for some $T$. Then for two arbitrary executions $t\to^* v_1$ and $t\to^* v_2$ where only $\secret$-graded values differ, we have $v_1=v_2$.
\end{theorem}

\section{Bidirectional Type Checking Algorithm}

\section{Implementation and Examples}

\section{Related Work}

Language-based IFC has a rich literature. Sabelfeld and Myers \cite{sabelfeld2003language} survey a variety of security type systems that enforce noninterference via typing. Seminal work by Volpano \emph{et al.} \cite{volpano1996sound} introduced a static type system for a simple imperative language, ensuring well-typed programs satisfy noninterference. Extensions include JFlow \cite{myers1999jflow} and JIF \cite{pullicino2014jif} for Java, which associate security labels with Java types to track flows, and FlowCaml \cite{simonet2003flow} for OCaml, which similarly adds a security type-checker. Generally, these systems label each variable as high or low and enforce rules so that no operation can use a high value in a low context.

More recently, graded type theories have been proposed to generalize such analyses. Graded type systems annotate types with additional information ("grades") to capture various properties of programs. For example, the Granule language \cite{orchard2019quantitative} uses graded modalities to track the effects and coeffects of program. In information flow use-cases, types are graded by a security lattice, allowing automatic enforcement of noninterference. Moon \emph{et al.} introduce the Graded Modal Dependent Type Theory (\textsc{GrTT}) \cite{moon2021graded}, which extends dependent type system with graded modality and show that the grades can be effective at reasoning of programs. This work demonstrates that graded modality can capture fine-grained flow policies in types. Similarly, Marshall and Orchard \citen{marshall2023graded} demonstrated a graded-modal framework that can enforce confidentiality and even integrity simultaneously.

Other approaches include dynamic IFC (e.g. LIO monad in Haskell \cite{stefan2011flexible}) or hybrid systems, but our focus is purely static. In summary, while classical security type sytems (JIF, FlowCaml, etc.) enforce noninterference via fixed lattice-labels. Our project draws on these ideas: we adapt graded modalities to a simple functional language to track information flows more flexibly.

\section{Further Work and Conclusion}

In summary, \textsc{FlowSTLC} has demonstrated that a simple lambda calculus with graded necessity can enforce secure information flow. By instantiating grades with the  security semiring $\secure$, our system statically tracks data labels at the type level. And with typing rules that enforcing the noninterference property, we guarantee that well-typed \textsc{FlowSTLC} programs cannot leak secrets. 

Despite these positive results, \textsc{FlowSTLC} in its current form is an \emph{idealized model} with clear limitations. For one, the core calculus is deliberately small and omits many practical language features. It has only base types and functions (no records, no algebraic data types, no recursive types, etc.), and it does not include polymorphism or dependent typing. As observed in prior work, static IFC models with minimal features have historically been considered "too limited or too restrictive to be used in practice" \cite{myers1999jflow}. Thus, our model inherits this limitation of expressiveness. Second, \textsc{FlowSTLC} exists only as a theoretical calculus and has not been integrated into a full-blown programming language. We consider that bridging this gap is a non-trivial challenge. For example, a recent survey noted that even in a rich language like Rust, implementing a sound IFC system requires "building an ad-hoc effect tracking system using bleeding-edge features of the Rust compiler". Finally, we have not evaluated performance or conducted real-world case studies. There are no benchmarks on typing or runtime costs, nor have we applied \text{FlowSTLC} to any non-trivial programs. In contrast, systems like JFlow and Cocoon \cite{lamba2024cocoon} have shown that static IFC checking can incur negligible overhead. Without such evaluation, the practical impact of \textsc{FlowSTLC} remains speculative.

Given these limitations, there are many promising directions for future work. We highlight several concrete directions:
\begin{itemize}
    \item \textbf{Extending the type system with dependent types and polymorphism.} One natural extension is to enrich \textsc{FlowSTLC} with more expressive typing disciplines. In particular, adding \emph{dependent types} could allow security policies to depend on program values and thus encode more precise confidentiality and declassification properties. Prior work (e.g. DepSec for Idris language \cite{gregersen2019dependently}) shows that dependent types increase the expressiveness of static IFCs. Similarly, introducing \emph{parametric polymorphism} would permit writing generic secure functions without duplicating code.
    \item \textbf{Combining graded modalities with effect, usage, or resource typing.} Another interesting direction is to study how the security grading interacts with other static analyses. Graded type theories generalize both effect systems (via graded monads) and coeffect/usage systems (via graded comonads). For example, \textsc{FlowSTLC} might be extended with an effect system that tracks side-effects or I/O on secret data (similar to Koka's effect typing system \cite{leijen2014koka} \cite{leijen2016algebraic}). Alternatively, one could explore \emph{coeffect-like} analyses where the context is graded alongside security. Integrating graded security labels with \emph{resource-} or \emph{capability-aware typing} could yield richer guarantees.
    \item \textbf{Embedding \textsc{FlowSTLC} in a practical language or compiler.} To bring theory closer to practice, a implementation of \text{FlowSTLC}'s typing discipline in a real programming environment is essential. One approach is to create a domain-specific language (DSL) or library for an existing language (e.g. Haskell or OCaml) that enforces these graded security types. Recent work (e.g. \cite{lamba2024cocoon}) shows that it is possible to add IFC to Rust without modifying the compiler. Similarly, the Granule project \cite{orchard2019quantitative} demonstrates that a language with graded, linear, and dependent types can be realized in practice. Following these examples, we could adapt \textsc{FlowSTLC}'s type checker into an implementation (for instance, a GHC plugin) to test on larger codebases. Such an embedding would enable empirical measurement of type-checking performance and runtime costs. It would also allow exploration of practical issues (language interoperability, tooling integration, etc.) that are vital for any real applications of our outcome.
\end{itemize}

In conclusion, \textsc{FlowSTLC} provides a formal foundation for secure information flow via graded modal types, but many challenges remain. Future work will pursue richer type features, deeper integration with program reasoning (effects, resources), and practical implementation efforts. We are optimistic that bridging these gaps will bring secure flow typing closer to real-world programming. By pursuing these directions, we hope to develop a mature framework that combines the rigorous guarantees of our type-theoretic approach with the expressiveness and practicality needed for deployed systems.

\section*{Acknowledgment}
We would like to express our sincere gratitude to the Theoretical Computer Science StackExchange user taquetgauche, who reviewed our early prototype type systems and provided valuable feedback on how to proceed.

We are also deeply thankful to all members of the Theoretical Computer Science Society of SUSTech for their continued support and for the many insightful ideas they shared with us throughout this project.

\bibliographystyle{IEEEtran}
\bibliography{term_project_report}

\newpage
\appendix

\subsection{Complete Specification of \textsc{FlowSTLC}}
\subsubsection{Syntax}
\begin{center}
	\begin{bnf}
		$t$ : \textsf{Term} ::=
		| $x$ : \textit{variable}
		| $t$ $t$ : \textit{application}
		| $\lam{x}{t}$ : \textit{abstraction}
		| $[t]$ : \textit{packing}
		| $\unp{x}{t\colon T}{t}$ : \textit{unpacking}
		;;
		$T$ : \textsf{Type} ::=
		| $T\to T$ : \textit{function type}
		| $\gradedt{r}{T}$ : \textit{graded modality}
		;;
		$v$ : \textsf{Value} ::=
		| $\lam{x\colon T}{t}$ : \textit{abstraction value}
		;;
		$\Gamma$ : \textsf{Context} ::=
		| $\emptyset$ : \textit{empty context}
        | $\Gamma,x\colon T$ : \textit{assumption}
		| $\Gamma,x\colon[T]_r$ : \textit{graded assumption}
		;;
		$\ell$ : \textsf{Security} ::=
		| \secret
		| \public
		| \irrele
		;;
	\end{bnf}
\end{center}

\subsubsection{Security Level Semiring}

\begin{definition}[Security Level Semiring]
The security level semiring $\mathbb{S}$ is a three-point lattice of security levels $\{\irrele\sqsubseteq\secret\sqsubseteq\public\}$ with 
\begin{itemize}
	\item $0=\irrele$
	\item $1=\secret$
	\item Addition as the join: $r+s=r\cup s$
	\item Multiplication as the join plus a special case: If $r$ or $s$ is $\irrele$, then $r\cdot s=\irrele$, otherwise $r\cdot s=r\sqcup s$
\end{itemize}
\end{definition}
See \hyperref[app-b]{Appendix B} for a proof that this algebra is a indeed a semiring.

\subsubsection{Auxiliary Definitions}
\label{def-concat}
\begin{definition}[Context Concatenation]
    $$
    \begin{aligned}
        \emptyset+\Gamma&=\Gamma\\
        \Gamma+\emptyset&=\Gamma\\
        (\Gamma,x:T)+\Gamma'&=(\Gamma+\Gamma'),x:T\text{ iff }x\notin dom(\Gamma')\\
        \Gamma+(\Gamma',x:T)&=(\Gamma+\Gamma'),x:T\text{ iff }x\notin dom(\Gamma')\\
        (\Gamma,x:[T]_r)+(\Gamma',x:[T]_s)&=(\Gamma+\Gamma'),x:[T]_{r+s}
    \end{aligned}
    $$
\end{definition}
\label{def-mul}
\begin{definition}[Context Scalar Multiplication]
    $$
    \begin{aligned}
    r\cdot\emptyset&=\emptyset\\
    r\cdot(\Gamma,x:[T]_s)&=(r\cdot\Gamma),x:[T]_{(r\cdot s)}\\
    \end{aligned}
    $$
\end{definition}

\subsubsection{Typing Rules}

\begin{prooftree}
	\AXC{$x:T\in\Gamma$}
	\RightLabel{\textsc{T-Var}}
	\UIC{$\Gamma\vdash x:T$}
\end{prooftree}

\begin{prooftree}
	\AXC{$\Gamma,x:T_1\vdash t:T_2$}
	\RightLabel{\textsc{T-Abs}}
	\UIC{$\Gamma\vdash\lam{x:T_1}{t}:T_1\to T_2$}
\end{prooftree}

\begin{prooftree}
	\AXC{$\Gamma_1\vdash t_1:T_{11}\to T_{12}$}
	\AXC{$\Gamma_2\vdash t_2:T_{11}$}
	\RightLabel{\textsc{T-App}}
	\BIC{$\Gamma_1+\Gamma_2\vdash t_1\; t_2:T_{12}$}
\end{prooftree}

\begin{prooftree}
	\AXC{$\Gamma\vdash t:T$}
	\RightLabel{\textsc{T-Weak}}
	\UIC{$\Gamma,\Gamma'\vdash t:T$}
\end{prooftree}

\begin{prooftree}
    \AXC{$\Gamma,x:T_1\vdash t:T_2$}
    \RightLabel{\textsc{T-Der}}
    \UIC{$\Gamma,x:[T_1]_\secret\vdash t:T_2$}
\end{prooftree}

\begin{prooftree}
	\AXC{$[\Gamma]\vdash t:T$}
	\RightLabel{\textsc{T-Pro}}
	\UIC{$\ell\cdot[\Gamma]\vdash[t]:\gradedt{\ell}{T}$}
\end{prooftree}
where $[\Gamma]$ denotes a context containing only graded assumptions.

\begin{prooftree}
	\AXC{$\Gamma_1\vdash t_1:\gradedt{\ell}{T_1}$}
	\AXC{$\Gamma_2,x:[T_1]_\ell\vdash t_2:T_2$}
	\RightLabel{\textsc{T-Let}}
	\BIC{$\Gamma_1+\Gamma_2\vdash\unp{x}{t_1}{t_2}:T_2$}
\end{prooftree}

\begin{prooftree}
	\AXC{$\Gamma,x:[T_2]_{\ell_1}\vdash t:T_1$}
	\AXC{$\ell_1\sqsubseteq\ell_2$}
	\RightLabel{\textsc{T-Approx}}
	\BIC{$\Gamma,x:[T_2]_{\ell_2}\vdash t:T_1$}
\end{prooftree}

\subsubsection{Evaluation Rules}

\begin{prooftree}
	\AXC{$t_1\to t_1'$}
	\RightLabel{\textsc{E-App1}}
	\UIC{$t_1\; t_2\to t_1'\; t_2$}
\end{prooftree}

\begin{prooftree}
	\AXC{$t_2\to t_2'$}
	\RightLabel{\textsc{E-App2}}
	\UIC{$v_1\; t_2\to v_1\; t_2'$}
\end{prooftree}

$$
(\lam{x:T}{t})\; v\to [x\mapsto v]t\quad\textsc{E-AppAbs}
$$

\begin{prooftree}
	\AXC{$t\to t'$}
	\RightLabel{\textsc{E-Pro}}
	\UIC{$[t]\to[t']$}
\end{prooftree}

\begin{prooftree}
	\AXC{$t_1\to t_1'$}
	\RightLabel{\textsc{E-Let-Eval}}
	\UIC{$\unp{x}{t_1}{t_2}\to\unp{x}{t_1'}{t_2}$}
\end{prooftree}

$$
\unp{x}{v}{t}\to [x\mapsto v]t\quad\textsc{E-Let-Unbox}
$$

\subsection{Proofs}
\subsubsection{Security Level Semiring}
\label{app-b}
\begin{proof}\leavevmode
	\begin{itemize}
		\item \textbf{Associativity of addition}: $(a+b)+c=a+(b+c)$
		
		This is trivial since the semiring addition is join, and join is associative in a lattice.
		\item \textbf{Commutativity of addition}: $a+b=b+a$
		
		This is also trivial since join is commutative in a lattice.
		\item \textbf{Additive identity}: $a+0=a$ for all $a$
		
		Since $0=\irrele$, and $\irrele$ be the minimum in $\secure$, we have
		\begin{equation}
			\begin{aligned}
				\public\sqcup\irrele&=\public\\
				\secret\sqcup\irrele&=\secret\\
				\irrele\sqcup\irrele&=\irrele\\			
			\end{aligned}
		\end{equation}
		\item \textbf{Associativity of multiplication}: $(a\cdot b)\cdot c=a\cdot (b\cdot c)$
		
		This is trivial by the associativity of join operation and the absorption nature of $\irrele$.
		
		\item \textbf{Multiplication distributes over addition}: $a\cdot(b+c)=(a\cdot b)+(a\cdot c)$ and $(a+b)\cdot c=(a\cdot c)+(b\cdot c)$
		
		\begin{itemize}
			\item If $a=\irrele$, then $a\cdot(b+c)=\irrele$ and $(a\cdot b)+(a\cdot c)=\irrele+\irrele$.
			\item Otherwise the distributivity comes from the associativity of the join operation.
		\end{itemize}
		
		\item \textbf{Multiplicative identity}: Since $1=\secret$ and $\irrele\sqsubseteq\secret\sqsubseteq\public$, we have
		\begin{equation}
			\begin{aligned}
				\secret\sqcup\secret&=\secret\\
				\public\sqcup\secret&=\public\\
				\irrele\sqcup\secret&=\irrele
			\end{aligned}
		\end{equation}
		\item \textbf{Multiplication by 0 annihilates}: $0\cdot a=a\cdot 0=0$ for all $a$
		
		This trivially holds to the absorption nature of $\irrele$.
	\end{itemize}
	Thus the security level algebra is a semiring.
\end{proof}

\subsubsection{Well-typed substitution}
We state several technical lemmas without proof:
\begin{lemma}[Restriction Collapse]
	For two typing contexts $\Gamma_1$ and $\Gamma_2$, we have
	$$
	\Gamma_{1|\Gamma_2}+\Gamma_{2|\overline{\Gamma_2}}=\Gamma_1
	$$
\end{lemma}
\begin{lemma}[Context Shuffle 1]
	For typing contexts $\Gamma_1$, $\Gamma_1'$, and $\Gamma_2$, variable $x$ and type $T$, we have
	$$
	(\Gamma_1,x:T,\Gamma_1')+\Gamma_2=(\Gamma_1+\Gamma_{2|\Gamma_1}),x:T,(\Gamma_1'+\Gamma_{2|\overline{\Gamma_1}})
	$$
\end{lemma}
\begin{lemma}[Context Shuffle 2]
	For typing contexts $\Gamma_1$, $\Gamma_2$, and $\Gamma_2'$, variable $x$ and type $T$, we have
	$$
	\Gamma_1+(\Gamma_2,x:T,\Gamma_2')=(\Gamma_{1|\Gamma_2}),x:T,(\Gamma_1'+\Gamma_{2|\overline{\Gamma_1}})
	$$
\end{lemma}
\begin{lemma}[Context Shuffle 3]
	
\end{lemma}
\begin{lemma}[Distribution of Scalar Multiplication over Context Concatenation]
	For typing context $\Gamma$ and two security levels $\ell_1,\ell_2\in\secure$, we have
	$$
	(\ell_1\cdot\Gamma)+(\ell_2\cdot\Gamma)=(\ell_1+\ell_2)\cdot\Gamma
	$$
\end{lemma}
\begin{lemma}
	
\end{lemma}
\begin{proof}
	By induction on a derivation of the form $\Gamma,x:S\vdash t:T$. For a given derivation, we proceed by cases on the final typing rule used in the proof.
	\begin{itemize}		
		\item\textbf{Case} \textsc{T-Var}: $t=z$ with $z:T\in(\Gamma,x:S)$
		
		We need to consider two subcases: 
		\begin{enumerate}
			\item if $z=x$, then $[x\mapsto s]z\to[x\mapsto s]x\to s$. So we need to show $\Gamma+\Delta\vdash s:S$. To get this first we apply the \textsc{T-Weak} rule to the assumption $\Delta\vdash s:S$,
			\item otherwise $[x\mapsto s]z\to z$, and the result is immediate.
		\end{enumerate}	
		
		\item\textbf{Case} \textsc{T-Abs}: $t=\lam{y:T_2}{t_1}$, $T=T_2\to T_1$, $\Gamma,x:S,y:T_2\vdash t_1:T_1$
		
		By convention we may assume that $x\ne y$ and $y\notin FV(s)$. Then by the permutation lemma and weakening rule, we have $\Gamma,\Delta,y:T_2,x:S\vdash t_1:T_1$. Again we apply the two rules on the assumption $\Delta\vdash s:S$ to get $\Gamma,\Delta,y:T_2\vdash s:S$. By the induction hypothesis, we have $\Gamma,\Delta,y:T_2\vdash [x\mapsto s]t_1:T_1$, then by \textsc{T-Abs} $\Gamma,\Delta\vdash \lam{y:T_2}{[x\mapsto s]t_1}:T_2\to T_1$, and this is our desired result.
		
		\item\textbf{Case} \textsc{T-App}: $t=t_1\; t_2$, $\Gamma,x:S\vdash t_1:T_2\to T_1$, $\Gamma,x:S\vdash t_2:T_2$, $T=T_1$
		
		By the induction hypothesis, we have $\Gamma,\Delta\vdash [x\mapsto s]t_1:T_2\to T_1$ and $\Gamma,\Delta\vdash [x\mapsto s]t_2:T_2$. Then by \textsc{T-App}, $\Gamma,\Delta\vdash [x\mapsto s]t_1\; [x\mapsto s]t_2:T_1$, i.e., $\Gamma,\Delta\vdash [x\mapsto s](t_1\; t_2):T_1$.
		
		\item\textbf{Case} \textsc{T-Weak}: $t=t_1$, $\Gamma'\vdash t_1:T$ where $\Gamma'\subseteq(\Gamma,x:S)$ and $x:S\in\Gamma'$
		
		By the induction hypothesis, we have $\Gamma',\Delta\vdash [x\mapsto s]t_1:T$, then apply the \textsc{T-Weak}, we have $\Gamma,\Delta\vdash [x\mapsto s]t_1:T$.
		
		\item\textbf{Case} \textsc{T-Der}: $t=t_1$, $T=T_1$, $\Gamma,x:S,y:T_2\vdash t_1:T_1$
		
		By the induction hypothesis and permutation lemma, we have $\Gamma,\Delta,y:T_2\vdash [x\mapsto s]t_1:T_1$. Then by the \text{T-Der} rule, we immediately have our desired result $\Gamma,\Delta,y:[T_2]_\public\vdash [x\mapsto s]t_1:T_1$.
		
		\item\textbf{Case} \textsc{T-Pro}:
		
		This case is impossible since \textsc{T-Pro} rule requires a purely graded context, and $x:S$ would violate the premise.
		
		\item\textbf{Case} \textsc{T-Let}: $t=\unp{y}{t_1}{t_2}$, $\Gamma_1,x:S\vdash t_1:\gradedt{\ell}{T_1}$, $\Gamma_2,y:[T_1]_\ell,x:S\vdash t_2:T_2$, $T=T_2$
		
		Again by convention we may assume that $x\ne y$ and $y\notin FV(s)$. First we apply the induction hypothesis to get $\Gamma_1,\Delta\vdash [x\mapsto s]t_1:\gradedt{\ell}{T_1}$ and $\Gamma_2,\Delta,y:[T_1]_\ell\vdash [x\mapsto s]t_2:T_2$. And it follows from the \textsc{T-Let} rule that $(\Gamma_1+\Gamma_2),\Delta\vdash\unp{y}{[x\mapsto s]t_1}{[x\mapsto s]t_2}:T_2$, i.e., $(\Gamma_1+\Gamma_2),\Delta\vdash[x\mapsto s](\unp{y}{t_1}{t_2}):T_2$.
		
		\item\textbf{Case} \textsc{T-Approx}: $t=t_1$, $\Gamma,x:S,y:[T_2]_{\ell_1}\vdash t_1:T_1$, $\ell_1\sqsubseteq\ell_2$, $T=T_1$.
		
		From the induction hypothesis and permutation lemma we can get $\Gamma,\Delta,y:[T_2]_{\ell_1}\vdash[x\mapsto s]t_1:T_1$. Then we apply the \textsc{T-Approx} rule to get our desired result $\Gamma,\Delta,y:[T_2]_{\ell_2}\vdash[x\mapsto s]t_1:T_1$.
	\end{itemize}
\end{proof}

\subsubsection{Well-typed Graded Substitution}
\begin{proof}
	Similar to how we prove the regular substitution lemma, we proceed by induction on a derivation of the form $\Gamma,x:[S]_\ell\vdash t:T$.
    \begin{itemize}
        \item \textbf{Case} \textsc{T-Var}: $t=z$ with $z:T\in(\Gamma,x:[S]_\ell)$
        
        Unlike the case for regular substitution lemma, $z$ cannot be $x$ since there is not rule that can introduce $\Gamma,\ell\cdot\Delta\vdash s:S$. So $z\ne x$, and we have $[x\mapsto s]z\to z$, and the result is immediate.
        \item \textbf{Case} \textsc{T-Abs}: $t=\lam{y:T_2}{t_1}$, $T=T_2\to T_1$, $\Gamma,x:[S]_\ell,y:T_2\vdash t_1:T_1$
        
        By convention we may assume that $x\notin FV(s)$. Then by
        \item \textbf{Case} \textsc{T-App}:
        \item \textbf{Case} \textsc{T-Weak}:
        \item \textbf{Case} \textsc{T-Der}:
        \item \textbf{Case} \textsc{T-Pro}:
        \item \textbf{Case} \textsc{T-Let}:
        \item \textbf{Case} \textsc{T-Approx}:
    \end{itemize}
\end{proof}

\subsubsection{Type Preservation}
\begin{proof}
	
\end{proof}
\end{document}
